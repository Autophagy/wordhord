
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">
    <meta name="theme-color" content="#000000">
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/static/css/main.css">
    <title>[2022-07-18] :: From Arch to NixOS</title>

    <meta property="og:type" content="article">
    <meta property="og:title" content="From Arch to NixOS">
    <meta property="og:description" content="2022-07-18 // 5 mins // [ Nix ]">
    <meta property="og:image" content="https://wordhord.autophagy.io/static/images/card.png">
    <meta name="twitter:card" content="summary_large_image">
</head>
    <body>
        <header>
            <div id="post-path">
                <a href="/">wordhord</a>
            </div>
            <div id="post-details">
                <div class="row">
                    <span class="label">title</span><span class="sep">::</span><span class="detail">From Arch to NixOS</span>
                </div>
                <div class="row">
                    <span class="label">published</span><span class="sep">::</span><span class="detail">2022-07-18</span>
                </div>
                <div class="row">
                    <span class="label">time</span><span class="sep">::</span><span class="detail">5 mins</span>
                </div>
                <div class="row">
                    <span class="label">tags</span><span class="sep">::</span><span class="detail">[  <a href="/tags/Nix">Nix</a>  ]</span>
                </div>
            </div>
        </header>
        <div id="content">
            <p>I've found my Arch Linux installations tend to be an accumulation
of packages, quick-fixes and hacks that weigh like a nightmare on my brain.
This is normally not the world's biggest deal, except when I
decide to try and trim down my installed packages and have to try and recall
why I installed X specific package 4 years ago.</p>
<p>It becomes more of a problem when I move between jobs (or just machines within
a job) and I'm suddenly confronted with a blank slate that I, yet again, have to
hammer and quick-fix back into the idiosyncratic shape that I like.</p>
<p>A few years ago, I turned to tools like Ansible to help define what shape I want
my machine to be in a declarative way. This works to some extent - except that I
am lazy. If I have to use a quick-fix or install a package and the choice is either:</p>
<ol>
<li>Install the quick-fix/package</li>
<li>Install the quick-fix/package to make sure it works, then encode it in an Ansible script</li>
</ol>
<p>then I will tend to choose number 1, or more accurately just entirely forget about number 2.
My Ansible definitions ended up being an outdated subset of the configuration of
my machine, a kind of configuration drift familiar to anyone who has to work with IaC tooling
without a regular CI/CD pipeline to enforce it.</p>
<p>A few years ago, on the back of learning Haskell more seriously, I encountered
<a href="https://github.com/NixOS/nix">Nix</a>. Frustrated with &quot;works-on-my-machine&quot; build processes at work with
lots of hidden or implicit dependencies that I had to figure out in order to automate
them, I was quite attracted to Nix's promise about reproducible builds. Nix is essentially
is a language/toolset to define the packaging of a piece of software, which
Nix calls a 'derivation'. Derivations are made up of the specific versioned inputs needed to build
a piece of software - not just the source code, but build dependency tools, packages
stuff like that. These derivations are then built with environments where the only
things allowed into the build environments are the inputs you've specified (which
is why these environments also have no network access).</p>
<p>When learning Nix you quickly come across <a href="https://nixos.org/">NixOS</a>, a Linux flavour based around the
Nix package manager. It extends the declarative focus of Nix to the system itself, letting
me define my system as a Nix expression:</p>
<pre lang="sh" style="background-color:#2d2d2d;"><code>
<span style="color:#d3d0c8;">  </span><span style="color:#6699cc;">hardware.pulseaudio.enable</span><span style="color:#d3d0c8;"> = true;
</span><span style="color:#d3d0c8;">
</span><span style="color:#d3d0c8;">  </span><span style="color:#6699cc;">hardware.bluetooth</span><span style="color:#d3d0c8;"> = {
</span><span style="color:#d3d0c8;">    enable = true;
</span><span style="color:#d3d0c8;">    powerOnBoot = pkgs.lib.mkForce false;
</span><span style="color:#d3d0c8;">  };
</span><span style="color:#d3d0c8;">
</span><span style="color:#d3d0c8;">  </span><span style="color:#6699cc;">networking.networkmanager.enable</span><span style="color:#d3d0c8;"> = true;
</span><span style="color:#d3d0c8;">
</span><span style="color:#d3d0c8;">  </span><span style="color:#6699cc;">time.timeZone</span><span style="color:#d3d0c8;"> = &quot;</span><span style="color:#99cc99;">Europe/Berlin</span><span style="color:#d3d0c8;">&quot;;
</span><span style="color:#d3d0c8;">  </span><span style="color:#6699cc;">i18n.defaultLocale</span><span style="color:#d3d0c8;"> = &quot;</span><span style="color:#99cc99;">en_GB.UTF-8</span><span style="color:#d3d0c8;">&quot;;
</span><span style="color:#d3d0c8;">
</span><span style="color:#d3d0c8;">  </span><span style="color:#6699cc;">services.xserver</span><span style="color:#d3d0c8;"> = {
</span><span style="color:#d3d0c8;">    layout = &quot;</span><span style="color:#99cc99;">us</span><span style="color:#d3d0c8;">&quot;;
</span><span style="color:#d3d0c8;">    xkbVariant = &quot;&quot;;
</span><span style="color:#d3d0c8;">    enable = true;
</span><span style="color:#d3d0c8;">    displayManager = {
</span><span style="color:#d3d0c8;">      lightdm.enable = true;
</span><span style="color:#d3d0c8;">      defaultSession = &quot;</span><span style="color:#99cc99;">none+i3</span><span style="color:#d3d0c8;">&quot;;
</span><span style="color:#d3d0c8;">    };
</span><span style="color:#d3d0c8;">    windowManager.i3.enable = true;
</span><span style="color:#d3d0c8;">
</span><span style="color:#d3d0c8;">    libinput.enable = true;
</span><span style="color:#d3d0c8;">  };
</span><span style="color:#d3d0c8;">
</span><span style="color:#d3d0c8;">  </span><span style="color:#6699cc;">virtualisation.podman</span><span style="color:#d3d0c8;"> = {
</span><span style="color:#d3d0c8;">    enable = true;
</span><span style="color:#d3d0c8;">    dockerCompat = true;
</span><span style="color:#d3d0c8;">  };
</span><span style="color:#d3d0c8;">
</span><span style="color:#d3d0c8;">  </span><span style="color:#6699cc;">users.users.mika</span><span style="color:#d3d0c8;"> = {
</span><span style="color:#d3d0c8;">    isNormalUser = true;
</span><span style="color:#d3d0c8;">    description = &quot;</span><span style="color:#99cc99;">Mika Naylor</span><span style="color:#d3d0c8;">&quot;;
</span><span style="color:#d3d0c8;">    extraGroups = </span><span style="color:#cc99cc;">[ </span><span style="color:#d3d0c8;">&quot;</span><span style="color:#99cc99;">networkmanager</span><span style="color:#d3d0c8;">&quot; &quot;</span><span style="color:#99cc99;">wheel</span><span style="color:#d3d0c8;">&quot; &quot;</span><span style="color:#99cc99;">audio</span><span style="color:#d3d0c8;">&quot; &quot;</span><span style="color:#99cc99;">video</span><span style="color:#d3d0c8;">&quot; </span><span style="color:#cc99cc;">]</span><span style="color:#d3d0c8;">;
</span><span style="color:#d3d0c8;">    shell = pkgs.zsh;
</span><span style="color:#d3d0c8;">  };
</span>
</code></pre>
<p>The crucial thing about this is that this isn't an extra layer of management on
top of regular methods of changing my system - with NixOS you're more or less forced
to define the system declaratively in order to induce change at all. I appreciate
that this distinction forces me to actually document the changes I make to my
system, the reasons I made it (in the git commit), and gives me the ability to
rebuild the system again if I need to.</p>
<p>Using <a href="https://github.com/nix-community/home-manager">Home Manager</a> has let me
even bundle my previously ad-hoc dotfile management system into the same Nix
expression format. For example, my <code>zsh</code> configuration now looks like:</p>
<pre lang="sh" style="background-color:#2d2d2d;"><code>
<span style="color:#d3d0c8;">{
</span><span style="color:#d3d0c8;">  </span><span style="color:#6699cc;">home.packages</span><span style="color:#d3d0c8;"> = with pkgs; </span><span style="color:#66cccc;">[</span><span style="color:#d3d0c8;"> pure-prompt </span><span style="color:#66cccc;">]</span><span style="color:#d3d0c8;">;
</span><span style="color:#d3d0c8;">
</span><span style="color:#d3d0c8;">  </span><span style="color:#6699cc;">programs.zsh</span><span style="color:#d3d0c8;"> = {
</span><span style="color:#d3d0c8;">    enable = true;
</span><span style="color:#d3d0c8;">    dotDir = &quot;</span><span style="color:#99cc99;">.config/zsh</span><span style="color:#d3d0c8;">&quot;;
</span><span style="color:#d3d0c8;">    enableSyntaxHighlighting = true;
</span><span style="color:#d3d0c8;">    shellAliases = {
</span><span style="color:#d3d0c8;">      ll = &quot;</span><span style="color:#99cc99;">ls -l</span><span style="color:#d3d0c8;">&quot;;
</span><span style="color:#d3d0c8;">      g = &quot;</span><span style="color:#99cc99;">git</span><span style="color:#d3d0c8;">&quot;;
</span><span style="color:#d3d0c8;">    };
</span><span style="color:#d3d0c8;">    history = {
</span><span style="color:#d3d0c8;">      size = 10000;
</span><span style="color:#d3d0c8;">      path = &quot;$</span><span style="color:#f2777a;">HOME</span><span style="color:#99cc99;">/.zsh_history</span><span style="color:#d3d0c8;">&quot;;
</span><span style="color:#d3d0c8;">      ignoreSpace = true;
</span><span style="color:#d3d0c8;">    };
</span><span style="color:#d3d0c8;">    initExtra = &quot;
</span><span style="color:#99cc99;">      autoload -U promptinit; promptinit
</span><span style="color:#99cc99;">      PURE_PROMPT_SYMBOL=</span><span style="color:#d3d0c8;">&quot;λ&quot;
</span><span style="color:#99cc99;">      prompt pure
</span><span style="color:#99cc99;">    </span><span style="color:#d3d0c8;">&quot;;
</span><span style="color:#d3d0c8;">    oh-my-zsh = {
</span><span style="color:#d3d0c8;">      enable = true;
</span><span style="color:#d3d0c8;">      plugins = </span><span style="color:#cc99cc;">[ </span><span style="color:#d3d0c8;">&quot;</span><span style="color:#99cc99;">ssh-agent</span><span style="color:#d3d0c8;">&quot; &quot;</span><span style="color:#99cc99;">git</span><span style="color:#d3d0c8;">&quot; </span><span style="color:#cc99cc;">]</span><span style="color:#d3d0c8;">;
</span><span style="color:#d3d0c8;">    };
</span><span style="color:#d3d0c8;">  };
</span><span style="color:#d3d0c8;">}
</span>
</code></pre>
<p>Although I'm worried that converting all my dotfiles into this very specific language/form
has a risk of lock-in, having everything defined the same way in the same language
does tickle some part of my monkey brain.</p>
<p>A downside of Nix/NixOS is that learning it can be quite hard. The community points
to the manuals as the resource for learning, but they often read like you need to
already understand the thing they're talking about for them to make sense. If I wasn't
already familiar with some FP concepts, I think I would have been totally lost. The
way I've mostly learned Nix/NixOS has been from spelunking around people's Nix expressions
on Github, which carries the risk of accidentally picking up bad practices or code smells.</p>
<p>I've only been using NixOS full time for a couple months but I'm already quite taken
with it, especially for a work/development machine. The way NixOS works makes me
feel like I have to be fairly principled about the definition of my machine - I
don't do the same thing I did on Arch of installing a package to try it out and
then forgetting that it's on my system for 3 years. With Nix I can try stuff out
with <code>nix-shell</code> and if I don't decide to make it part of my system, the binaries
get cleaned out on the next nix garbage collection. I'm still keeping Arch on my
personal machine mostly out of pure inertia, but also because I'm a little scared
about getting Steam and all the associated drivers working.</p>
<p>My new, fancy, enflakened NixOS files now live on the main branch of my <a href="https://github.com/autophagy/antimber">Antimber</a>
repo. I've not run into any blocking problems with it yet as my daily driver,
and picking it up has definitely helped give me the confidence to convert
my projects' existing build processes to Nix Flakes. I'll check back in 6-12 months
down the line to see if I still feel the same way.</p>

        </div>
        
<footer>
    <div id="derivation">
        <a href="https://github.com/autophagy/wordhord">/nix/store/2bajifdpxk82hfw890fb4w95wx7vjqh9-wordhord-0.1.0</a>
    </div>
</footer>

    </body>
</html>
